<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LeetCode做题总结(updating)</title>
    <url>/2020/04/26/014LeetCode%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p> LeetCode刷题总结（Updating…）</p>
<p>为了强化做题的效果，完成一些题目之后将题解进行总结回顾，加深印象，持续更新中…</p>
<a id="more"></a>
<p>目前已经完成的题目编号：1、7、9、13、14、27、28、35、53、58、66、67、69、70、83、88、100、101、104、111、121、122、141、461、728、942、1281、1295、1304、1309、1313、1342、1365、1385、LCP01</p>
<h2 id="Chapt-00准备资料"><a href="#Chapt-00准备资料" class="headerlink" title="Chapt-00准备资料"></a><strong>Chapt-00准备资料</strong></h2><p><strong>0000资料</strong></p>
<p><a herf="https://github.com/azl397985856/leetcode">LeetCode学习资料</a></p>
<p><a herf="https://github.com/OUCMachineLearning/OUCML/tree/master/%E4%BB%A3%E7%A0%81%E9%80%9F%E6%9F%A5%E8%A1%A8">代码速查表</a></p>
<p><a herf="https://github.com/MisterBooo/LeetCodeAnimation">图解LeetCode</a></p>
<h2 id="Chapt-01链表"><a href="#Chapt-01链表" class="headerlink" title="Chapt-01链表"></a><strong>Chapt-01链表</strong></h2><p> <strong>0141 Link list Circle <a herf="https://leetcode-cn.com/problems/linked-list-cycle/">环形链表</a></strong></p>
<ul>
<li><p>当一个链表有环时，快慢指针都会陷入环中进行无限次移动，然后变成了追及问题。想象一下在操场跑步的场景，只要一直跑下去，快的总会追上慢的。当两个指针都进入环后，每轮移动使得慢指针到快指针的距离增加一，同时快指针到慢指针的距离也减少一，只要一直移动下去，快指针总会追上慢指针。</p>
<center>

<p><img src="https://pic.leetcode-cn.com/d1ac82780e5189d7d58406504c3b7b56c35165997bfbb4c325677af92ee2d483.gif" alt="avatar"></p>
</center>
根据上述表述得出，如果一个链表存在环，那么快慢指针必然会相遇。实现代码如下

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *fast,*slow;</span><br><span class="line">        fast=head;</span><br><span class="line">        slow=head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast!=<span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                fast=fast-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fast==slow) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>面试0203 <a herf="https://leetcode-cn.com/problems/delete-middle-node-lcci/">删除中间节点</a></strong></p>
<ul>
<li>实现一种算法，删除单向链表中间的某个节点（除了第一个和最后一个节点，不一定是中间节点），假定你只能访问该节点。下面就是删除地址为node的节点。</li>
</ul>
<blockquote>
<p>因为通过当前节点，我们只能知道后面节点的地址和内容，所以可以将当前要删除节点后面的那一个节点完全拷贝到当前节点，然后在将其删除。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        ListNode *p=node-&gt;next;<span class="comment">//定义一个node后面的节点</span></span><br><span class="line"></span><br><span class="line">        node-&gt;val=p-&gt;val;<span class="comment">//将node后面的节点的值赋给当前</span></span><br><span class="line">        node-&gt;next=p-&gt;next;<span class="comment">//将p节点指针区也拷给node</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span>(p);<span class="comment">//将p进行删除</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>0021  Merge Two Sorted Lists <a herf="https://leetcode-cn.com/problems/merge-two-sorted-lists/">合并两个有序链表</a></strong></p>
<h3 id="解法1（递归法）"><a href="#解法1（递归法）" class="headerlink" title="解法1（递归法）:"></a>解法1（递归法）:</h3><ul>
<li>解决此道题目的有效方法为递归法，因为给出的函数的目的就是希望将两个链表进行合并。</li>
<li>合并结束的标志为：其中一个链表到达最后一个节点，指针去指向NULL。<blockquote>
<p>解决此题的主要思路：首先比较两个链表的第一个数据区域的大小，哪个小，哪个就保留住，然后其下一个，就是从两个链表中各在找出一个节点继续比较大小。<br>&emsp;递归法的程序实现：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="literal">NULL</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l2==<span class="literal">NULL</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l1-&gt;val&lt;l2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            l1-&gt;next=mergeTwoLists(l1-&gt;next,l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            l2-&gt;next=mergeTwoLists(l1,l2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解法2（迭代法）："><a href="#解法2（迭代法）：" class="headerlink" title="解法2（迭代法）："></a>解法2（迭代法）：</h3></li>
<li>定义一个新的头节点</li>
<li>比较l1节点数值和l2节点数值的大小，将小的放在头节点的后面</li>
<li>循环执行，直至二者其中一个为NULL</li>
<li>最后，将l2或者l1中剩余的部分链接到头节点后面<blockquote>
<p>程序如下：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* head = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        ListNode* ret = head;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">NULL</span> &amp;&amp; l2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                head-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                head-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        head-&gt;next = l1 == <span class="literal">NULL</span> ? l2 : l1;</span><br><span class="line">        <span class="keyword">return</span> ret-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>面试题.0202  Kth Node From End of List LCCI <a herf="https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/">链表中倒数第K个节点的值</a></strong></p>
<ul>
<li>关键思想：快慢指针</li>
<li>先让快指针走k次，然后一块走，当快指针走到NULL时，慢指针恰好处在倒数第K个位置<br><img src="https://pic.leetcode-cn.com/b6e913997ffa01167ac3c89fef7172a14fb46d22f20c8eb5db3c663b0523cc3e.png" alt="快慢指针实现图解"><center>快慢指针实现过程</center>

</li>
</ul>
<blockquote>
<p>编程代码如下：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthToLast</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode *p=head;</span><br><span class="line">        ListNode *q=head;</span><br><span class="line">        <span class="keyword">while</span>(k--)</span><br><span class="line">        &#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            q=q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q-&gt;val;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Chapt-02数组"><a href="#Chapt-02数组" class="headerlink" title="Chapt-02数组"></a><strong>Chapt-02数组</strong></h2><p><strong>1010  song can be divided by 60 <a herf="https://leetcode-cn.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/">总持续时间可被60整除的歌曲</a></strong></p>
<ul>
<li>解决此题的关键之处在于算法的优化，当然使用暴力法当然可以，但数组长度过长时容易因为时间限制而不能通过，下面简单介绍一下优秀的遍历方法</li>
<li>首先遍历一遍数组，将所有元素对60取余数，生成一个新的数组，并且将这些余数进行排序，sort()函数实现。</li>
<li>通过一个新定义的数组来记录各个余数出现的次数，余数作为下标，下标对应的数值为该余数出现的次数。</li>
<li>然后就是开启第二次循环，将0-30的之间的余数对应的30-60的数目加起来，最后在单独处理一些0与30这两种情况，根据两两结合的原理公式计算。<br>&emsp;&emsp;程序实现的方法如下：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="keyword">int</span> count[<span class="number">61</span>],res = <span class="number">0</span>;<span class="comment">//用来存储各个余数出现的次数的数组</span></span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">numPairsDivisibleBy60</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(time.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(count,<span class="number">0</span>,<span class="keyword">sizeof</span> count);<span class="comment">//将里面的元素初始化为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; time.size(); i++)&#123;</span><br><span class="line">            time[i] %= <span class="number">60</span>;<span class="comment">//将时间转化为6o的余数</span></span><br><span class="line">            count[time[i]]++;<span class="comment">//记录各个余数出现的次数，没有出现则默认为0</span></span><br><span class="line">        &#125;</span><br><span class="line">        sort(time.begin(),time.end());<span class="comment">//将余数进行排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; time.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(time[i] &gt;= <span class="number">30</span>) <span class="keyword">break</span>;<span class="comment">//超过或者等于30就跳出循环</span></span><br><span class="line">            <span class="keyword">if</span>(time[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            res += count[<span class="number">60</span> - time[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        res += (count[<span class="number">0</span>]*(count[<span class="number">0</span>]<span class="number">-1</span>))/<span class="number">2</span>;</span><br><span class="line">        res += (count[<span class="number">30</span>]*(count[<span class="number">30</span>]<span class="number">-1</span>))/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Chapt-03递归"><a href="#Chapt-03递归" class="headerlink" title="Chapt-03递归"></a><strong>Chapt-03递归</strong></h2></li>
</ul>
<h2 id="Chapt-04树"><a href="#Chapt-04树" class="headerlink" title="Chapt-04树"></a><strong>Chapt-04树</strong></h2><h2 id="Chapt-05栈和队列"><a href="#Chapt-05栈和队列" class="headerlink" title="Chapt-05栈和队列"></a><strong>Chapt-05栈和队列</strong></h2><h2 id="Chapt-06查找"><a href="#Chapt-06查找" class="headerlink" title="Chapt-06查找"></a><strong>Chapt-06查找</strong></h2><h2 id="Chapt-07排序"><a href="#Chapt-07排序" class="headerlink" title="Chapt-07排序"></a><strong>Chapt-07排序</strong></h2>]]></content>
      <tags>
        <tag>LeetCode 笔记 算法 数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习笔记(updating)</title>
    <url>/2020/04/01/013C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<center><font size="4">记录学习过程中遇到的问题以及十分重要的知识点</font></center>
<a id="more"></a>

<h2 id="宏定义与条件编译"><a href="#宏定义与条件编译" class="headerlink" title="宏定义与条件编译"></a><strong>宏定义与条件编译</strong></h2><blockquote>
<p><strong>宏定义：</strong></p>
</blockquote>
<ul>
<li>定义形式：</li>
</ul>
<p>用一个指定的标志符来代表一个字符串，其定义为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.1415926</span></span><br></pre></td></tr></table></figure>
<ul>
<li>功能用途：</li>
</ul>
<ol>
<li>可以减少程序中重复性输入某些重用字符串的工作量。</li>
<li>一改全改<blockquote>
<p><strong>条件编译</strong></p>
</blockquote>
</li>
</ol>
<ul>
<li>定义：</li>
</ul>
<p>一般情况下，源程序中所有的行都要参加编译，但有时候需要对程序中某一部分在满足一定的情况下才进行编译，也就是对部分程序限定编译条件；另外，我们希望当满足某一条件时对一组程序进行编译，当满足另外一种情况时则编译另外一组程序。</p>
<ul>
<li>使用方法：</li>
</ul>
<p>主要由两种形式，类似于判断语句，宏定义相当于编译的开关：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMPUTER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LANGUAGE</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    ''''</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> COMPUTER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// </span></span></span><br><span class="line">	<span class="keyword">int</span> size = SIZE;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"size="</span> &lt;&lt; size &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"这是一个条件编译指令的测试"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// DEBUG</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//与ifdef相反的因素是ifndef,理解起来方法是完全相同的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LANGUAGE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHINA <span class="meta-string">"Chinese"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !LANGUAGE</span></span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"添加CHINA的定义后："</span> &lt;&lt; CHINA &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结构体与类的定义与区别"><a href="#结构体与类的定义与区别" class="headerlink" title="结构体与类的定义与区别"></a><strong>结构体与类的定义与区别</strong></h2><blockquote>
<p> C结构体、C++结构体基本相同，C++类主要是方法的实现。</p>
</blockquote>
<p><strong>结构体是数据类型的集合</strong></p>
<p><strong>类是数据类型加方法的集合，基本如此，更注重方法。</strong></p>
<h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a><strong>malloc</strong></h2><ul>
<li><strong>在链表中插入新的结点时可能会用的到</strong></li>
<li>头文件#include&lt;malloc.h&gt;</li>
<li>功能：分配长度为num_bytes字节的内存块 </li>
<li>说明：如果分配成功则返回指向被分配内存的指针，否则返回空指针NULL。 </li>
<li>当内存不再使用时，应使用free()函数将内存块释放</li>
<li>malloc()函数其实就在内存中找一片指定大小的空间，然后将这个空间的首地址范围给一个指针变量，这里的指针变量可以是一个单独的指针，也可以是一个数组的首地址，这要看malloc()函数中参数size的具体内容。我们这里malloc分配的内存空间在逻辑上连续的，而在物理上可以连续也可以不连续。对于我们程序员来说，我们关注的是逻辑上的连续，因为操作系统会帮我们安排内存分配，所以我们使用起来就可以当做是连续的。</li>
<li>注意的地方：由于malloc函数返回的是void 类型。对于C++，如果你写成：p = malloc (sizeof(int));则程序无法通过编译，报错：“不能将void*赋值给int *类型变量”。所以必须通过(int *)来将强制转换。而对于C，没有这个要求，但为了使C程序更方便的移植到C++中来，建议养成强制转换的习惯<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* p;</span><br><span class="line"><span class="comment">//分配128个（可根据实际需要替换该数值）整型存储单元，并将这128个连续的整型存储单元的首地址存储到指针变量p中</span></span><br><span class="line">p = (<span class="keyword">int</span> *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">128</span>);</span><br><span class="line"><span class="comment">//分配12个double型存储单元，并将首地址存储到指针变量pd中</span></span><br><span class="line"><span class="keyword">double</span> *pd=(<span class="keyword">double</span> *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(<span class="keyword">double</span>)*<span class="number">12</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">char</span> *p;  </span><br><span class="line"> </span><br><span class="line">    p=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);  </span><br><span class="line">    <span class="keyword">if</span>(p)  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Memory Allocated at: %x/n"</span>,p);  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Not Enough Memory!/n"</span>);  </span><br><span class="line">    <span class="built_in">free</span>(p);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="typedef的用法"><a href="#typedef的用法" class="headerlink" title="typedef的用法"></a><strong>typedef的用法</strong></h2><ul>
<li>typedef主要是用来自定义数据类型，可以对所有现存的数据类型进行个性化的重新定义，增加所对应类型变量的个性化程度与单一性，便于在众多变量中将某一大类具有相似关系的变量统一定义。</li>
<li>用在旧的C的代码中（具体多旧没有查），帮助struct。以前的代码中，声明struct新对象时，必须要带上struct，即形式为： struct 结构名 对象名，如：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagPOINT1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagPOINT1</span> <span class="title">p1</span>;</span></span><br></pre></td></tr></table></figure></li>
<li>可能现在在C++中没有那么明显，可以直接写 结构名 对象名，或许，在C++中，typedef的这种用途二不是很大，但是理解了它，对掌握以前的旧代码还是有帮助的，毕竟我们在项目中有可能会遇到较早些年代遗留下来的代码。</li>
<li>但在C中估计某人觉得经常多写一个struct太麻烦了，于是就发明了：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagPOINT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line">&#125;POINT;</span><br><span class="line"></span><br><span class="line">POINT p1; <span class="comment">// 这样就比原来的方式少写了一个struct，比较省事，尤其在大量使用的时候</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="z-x-gt-y-x-y"><a href="#z-x-gt-y-x-y" class="headerlink" title="z=x&gt;y? x : y"></a><strong>z=x&gt;y? x : y</strong></h2><p>&emsp;其实，这是一个非常基本的知识点，但是有些时候突然见到会想不起来，翻译一下就相当于：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(x&gt;y)</span><br><span class="line">&#123;</span><br><span class="line">    z=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    z=y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;也就是可以理解为<strong>result=条件 ? 结果1 : 结果2</strong> 里面的？号是格式要求。也可以理解为条件是否成立，条件成立为结果1，否则为结果2。</p>
<h2 id="memset-函数"><a href="#memset-函数" class="headerlink" title="memset()函数"></a><strong>memset()函数</strong></h2><p> &emsp;&emsp;这个函数在socket中多用于清空数组.如:原型是memset(buffer, 0, sizeof(buffer))。简言之，就是用来将数组进行初始化的函数。</p>
<ul>
<li>这个函数有三个参数，前两个为初始化数组对象及其初始化的值，最后一个通常使用sizeof()函数来写，也可以直接写具体大小n。</li>
<li>注意，如果是对指针变量所指向的内存单元进行清零初始化，那么一定要先对这个指针变量进行初始化，即一定要先让它指向某个有效的地址。而且用memset给指针变量如p所指向的内存单元进行初始化时，n 千万别写成 sizeof(p)，这是新手经常会犯的错误。因为 p 是指针变量，不管 p 指向什么类型的变量，sizeof(p) 的值都是 4。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;  <span class="comment">//循环变量</span></span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> *p = str;</span><br><span class="line">    <span class="built_in">memset</span>(str, <span class="number">0</span>, <span class="keyword">sizeof</span>(str));  <span class="comment">//只能写sizeof(str), 不能写sizeof(p)</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\x20"</span>, str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="vector的使用"><a href="#vector的使用" class="headerlink" title="vector的使用"></a><strong>vector的使用</strong></h2>&emsp;&emsp;vector在C++的功能与数组类似，不过其优点在于其大小长度为动态的，在进行初始化定义的时候并不需要像数组那样去初始化其长度。同时，其特殊之处又决定了vector具体在使用时需要注意的细节：<ul>
<li>往其中加入新元素时需要用 数组名.push_back(加入的元素)&emsp;来实现，<strong>而不能直接访问为初始化或者未定义的下标</strong>。</li>
<li>同时也可以对其进行初始化n个元素。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;<span class="comment">//定义动态数组nums</span></span><br><span class="line"><span class="comment">//nums.[0]=0     //不可以对未定义下标直接赋值</span></span><br><span class="line">nums.psuh_back(<span class="number">1</span>)<span class="comment">//相当于数组中的nums[0]=1;</span></span><br><span class="line">nums[<span class="number">0</span>]=<span class="number">100</span>;     <span class="comment">//可以修改已定义的下标</span></span><br></pre></td></tr></table></figure>
<h2 id="getchar-和system-“puse”-函数"><a href="#getchar-和system-“puse”-函数" class="headerlink" title="getchar()和system(“puse”)函数"></a><strong>getchar()和system(“puse”)函数</strong></h2>这两个可以用在VScode的最后面，用于终端窗口的保持，防止其弹出瞬间就突然消失。</li>
<li>有时，我们不希望终端窗口弹出，因为只需要在下面的终端栏中也可现实。关闭窗口的弹出可以修改.vscode文件下的lanunch.json，将下面的 “externalConsole” 初始设置为false即可。(可根据个人喜好更改)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="string">"externalConsole"</span>: <span class="literal">false</span>,</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="枚举类型menu的用法"><a href="#枚举类型menu的用法" class="headerlink" title="枚举类型menu的用法"></a><strong>枚举类型menu的用法</strong></h2><p>众所周知，C/C++语言可以使用#define和const创建符号常量，而使用enum工具不仅能够创建符号常量，还能定义新的数据类型，但是必须按照一定的规则进行，下面我们一起看下enum的使用方法</p>
<ul>
<li>(1)以下代码定义了这种新的数据类型 - 枚举型<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> DAY</span><br><span class="line">&#123;</span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
(1) 枚举型是一个集合，集合中的元素(枚举成员)是一些命名的整型常量，元素之间用逗号,隔开。</li>
</ul>
<p>(2) DAY是一个标识符，可以看成这个集合的名字，是一个可选项，即是可有可无的项。</p>
<p>(3) 第一个枚举成员的默认值为整型的0，后续枚举成员的值在前一个成员上加1。</p>
<p>(4) 可以人为设定枚举成员的值，从而自定义某个范围内的整数。</p>
<p>(5) 枚举型是预处理指令#define的替代。</p>
<p>(6) 类型定义以分号;结束。</p>
<ul>
<li>(2)用typedef关键字将枚举类型定义成别名，并利用该别名进行变量声明<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> workday</span><br><span class="line">&#123;</span><br><span class="line">    saturday,</span><br><span class="line">    sunday = <span class="number">0</span>,</span><br><span class="line">    monday,</span><br><span class="line">    tuesday,</span><br><span class="line">    wednesday,</span><br><span class="line">    thursday,</span><br><span class="line">    friday</span><br><span class="line">&#125; workday; <span class="comment">//此处的workday为枚举型enum workday的别名</span></span><br></pre></td></tr></table></figure>
后面就可以直接使用workday来定义枚举类型了，比如<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">workday today, tomorrow; <span class="comment">//变量today和tomorrow的类型为枚举型workday，也即enum workday</span></span><br></pre></td></tr></table></figure>
具体使用参考示例（C语言）：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Season</span><br><span class="line">&#123;</span><br><span class="line">    spring, summer=<span class="number">100</span>, fall=<span class="number">96</span>, winter</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday</span><br><span class="line">&#125;</span><br><span class="line">Weekday;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Season */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d \n"</span>, spring); <span class="comment">// 0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d, %c \n"</span>, summer, summer); <span class="comment">// 100, d</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d \n"</span>, fall+winter); <span class="comment">// 193</span></span><br><span class="line"></span><br><span class="line">    Season mySeason=winter;</span><br><span class="line">    <span class="keyword">if</span>(winter==mySeason)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"mySeason is winter \n"</span>); <span class="comment">// mySeason is winter</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span>(x==summer)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"x is equal to summer\n"</span>); <span class="comment">// x is equal to summer</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d bytes\n"</span>, <span class="keyword">sizeof</span>(spring)); <span class="comment">// 4 bytes</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Weekday */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sizeof Weekday is: %d \n"</span>, <span class="keyword">sizeof</span>(Weekday)); <span class="comment">//sizeof Weekday is: 4</span></span><br><span class="line"></span><br><span class="line">    Weekday today = Saturday;</span><br><span class="line">    Weekday tomorrow;</span><br><span class="line">    <span class="keyword">if</span>(today == Monday)</span><br><span class="line">        tomorrow = Tuesday;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tomorrow = (Weekday) (today + <span class="number">1</span>); <span class="comment">//remember to convert from int to Weekday</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="二重指针"><a href="#二重指针" class="headerlink" title="二重指针"></a><strong>二重指针</strong></h2><p>&emsp;&emsp;所谓的二重指针，就是一种指向指针变量类型的指针。首先对于一个指针变量而言，它需要占用内存空间，即它本身是具有地址的，只不过对应内存空间中存放的是指针变量所指向变量的地址。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b=<span class="number">2</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"整形数据"</span>&lt;&lt;a&lt;&lt;<span class="string">"的地址为："</span>&lt;&lt;&amp;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"整形数据"</span>&lt;&lt;b&lt;&lt;<span class="string">"的地址为："</span>&lt;&lt;&amp;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> *p1=&amp;a;<span class="comment">//定义了默认指向整型变量a的地址的指针变量p1</span></span><br><span class="line"><span class="keyword">int</span> *p2=&amp;b;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"指针变量p1中存放的地址为："</span>&lt;&lt;p1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"指针变量p2中存放的地址为："</span>&lt;&lt;p2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//指针变量本身也具有地址：</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"指针变量p1本身的地址为："</span>&lt;&lt;&amp;p1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"指针变量p2本身的地址为："</span>&lt;&lt;&amp;p2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> **q=&amp;p1;<span class="comment">//q是一个指向（指向int数据类型指针）变量p1的指针，注意括号里面的描述，p1本身又是一个指向int数据类型的指针。也就是说，q里面存放的其实是p1的地址，那么*q表示的就是p1本身。所以有**q=*p1=a=1。</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;程序的输出为：</p>
<p><img src="https://s1.ax1x.com/2020/05/04/YCPQW8.png" alt="YCPQW8.png"></p>
]]></content>
      <tags>
        <tag>C++ 笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Visual Stdio 2017软件功能分析</title>
    <url>/2020/04/01/%E6%9C%AA%E5%8F%91%E9%80%81/012visual%20stdio%E8%BD%AF%E4%BB%B6%E7%A0%94%E7%A9%B6/</url>
    <content><![CDATA[<center><font size="5" face="黑体">Visual Stdio 2017使用细则</font></center>
本科时程序设计所使用的软件为Codeblocks，体积量相对较小，使用起来也比较简单，但当时主要是进行C语言程序设计。最近正在进行C++的学习，就C++开发来说，在我的Windows下最强大最好用的开发工具那必然是visualstdio。刚开始上手这款开发工具，不定期地记录一些使用过程中的功能细则。

<h3 id="1-新建项目时包含默认的头文件-include”pch-h”"><a href="#1-新建项目时包含默认的头文件-include”pch-h”" class="headerlink" title="1.新建项目时包含默认的头文件#include”pch.h”"></a>1.新建项目时包含默认的头文件#include”pch.h”</h3><blockquote>
<p><strong>解释</strong></p>
</blockquote>
<p><em>pch*是</em>“precomplied headfile”*的缩写,可以使用不同的名称,或者不使用。（在项目 - 属性 - C/C++ - 预编译头 可以关闭）<br><img src="https://pic.downk.cc/item/5e83ecae504f4bcb04c3e33c.jpg" alt></p>
<blockquote>
<p><strong>作用</strong></p>
</blockquote>
<p>一般是用在操作量大的工程里，可以预编译较稳定的代码（不经常修改的），可以<strong>加速后续的编译过程</strong>（因为有些代码已经编译过了）</p>
<h3 id="快捷键的使用和操作"><a href="#快捷键的使用和操作" class="headerlink" title="快捷键的使用和操作"></a>快捷键的使用和操作</h3>]]></content>
      <tags>
        <tag>VisualStdio 软件</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中argc与argv的作用</title>
    <url>/2020/03/31/011C++%E4%B8%ADargc%E5%92%8Cargv%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>在研究别人写的代码时，经常会发现在main函数中加入了两个定义：int argc,int *argv</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常在旧版本的IDE中新建一个C/C++源文件，通常也会见到上述mian函数括号中的定义，下面就介绍一下这种使用方法的作用。</p>
<h2 id="细节分析"><a href="#细节分析" class="headerlink" title="细节分析"></a>细节分析</h2><p>根据函数参数传递的特性和，main()函数中传递了两个形式参数，int类型的argc以及字符类型的数组指针argv。下面研究一下，两个形参的默认值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"argc: "</span>&lt;&lt;argc&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"argv: "</span>&lt;&lt;argv[<span class="number">0</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再输出窗口中看到如下结果：<br><img src="https://pic.downk.cc/item/5e834329504f4bcb04439dec.jpg" alt="110"></p>
<p>可见，argc的默认值为1，argv首元素为程序的位置路径。 看到这里你肯定明白了，argc是argv中存放string的数量，有了这个我们就可以遍历这个数组了。</p>
<h2 id="最后说明"><a href="#最后说明" class="headerlink" title="最后说明"></a>最后说明</h2><ol>
<li><p>argc 是 argument count的缩写，表示传入main函数的参数个数；</p>
</li>
<li><p>argv 是 argument vector的缩写，表示传入main函数的参数序列或指针，并且第一个参数argv[0]一定是程序的名称，并且包含了程序所在的完整路径，所以确切的说需要我们输入的main函数的参数个数应该是argc-1个；</p>
<ol start="3">
<li>如果程序要读取某文件的信息，而该文件的名称不是在程序中给定，而是由用户确定，那么给main传参数就是一个很好的方法.</li>
</ol>
</li>
<li><p>argc,argv可以使程序接受命令行参数，更方便的IO</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Windows系统下基于putty+VNC与树莓派4B连接</title>
    <url>/2020/03/16/010%E6%A0%91%E8%8E%93%E6%B4%BEpuutty/</url>
    <content><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1584371094015&di=f0d8c4fd96aee78cbf386c55e872a9fe&imgtype=0&src=http%3A%2F%2Fmp.ofweek.com%2Fdata%2Fimages%2Fpchome%2F2020-02-28%2F7d77ace6438ab259e5c897ba265229f4.png" alt="image.png"></p>
<a id="more"></a>
<p>&ensp;&ensp;去年12月份花了500多大洋入手了一个树莓派4B，顶配的4GB RAM.当时想着是学习一下Linux系统，并基于树莓派进行一些DIY开发。这块板子刚取到后我就去听了学校的大师论坛讲座，那天的汇报人是数学界大佬丘成桐，讲座结束之后有幸要到了大佬在我的包装盒上的签名。</p>
<p><img src="https://i.loli.net/2020/03/16/IVSyBa5tXJpmfWj.png" alt="image.png"></p>
<p>&ensp;&ensp;但是，自从买回来之后这块树莓派就一直放在那里吃灰，期间试着在无显示屏的情况下进行连接。今天整理物品时将其找了出来，想着干脆学学这玩意儿。下面就先介绍无显示屏情况下进入树莓派系统的方法。</p>
<h2 id="00准备工作"><a href="#00准备工作" class="headerlink" title="00准备工作"></a>00准备工作</h2><blockquote>
<p>设备：<strong>树莓派裸板</strong>、<strong>网线</strong>、<strong>笔记本</strong></p>
</blockquote>
<blockquote>
<p>软件：</p>
</blockquote>
<blockquote>
<p><strong>putty</strong>(<a href="https://putty.en.softonic.com/" target="_blank" rel="noopener">https://putty.en.softonic.com/</a>)<br><strong>VNCViewer</strong>(<a href="https://www.realvnc.com/en/connect/download/viewer/)。" target="_blank" rel="noopener">https://www.realvnc.com/en/connect/download/viewer/)。</a></p>
</blockquote>
<p>&ensp;&ensp;两款软件均为开源免费，下载后无脑安装。</p>
<h2 id="01、将WLAN设置为共享模式"><a href="#01、将WLAN设置为共享模式" class="headerlink" title="01、将WLAN设置为共享模式"></a>01、将WLAN设置为共享模式</h2><p>&ensp;&ensp;首先将利用网线将树莓派和笔记本的网口连接起来,然后进入WIndows的设置中心,选择进入网络和Internet设置.左边选择WLAN右边选择更改适配器选项<img src="https://i.loli.net/2020/03/16/pjkzNIStJoOPcmf.png" alt="image.png"></p>
<p>&ensp;&ensp;接着进入网络连接设置选项,右键WALN,选择属性,进入属性设置界面.</p>
<p><img src="https://i.loli.net/2020/03/16/qaRXFCD36Z2WpkT.png" alt="image.png"></p>
<p>&ensp;&ensp;然后选择上方的共享,勾选两个选框,家庭网络连接选择以太网,点击确定,此时会发现WLAN的名称后面多了:”共享的”三个字。</p>
<p><img src="https://i.loli.net/2020/03/16/E25NJFjiTfQGZzq.png" alt="image.png"></p>
<h2 id="02-利用命令提示符查询树莓派的IP"><a href="#02-利用命令提示符查询树莓派的IP" class="headerlink" title="02 利用命令提示符查询树莓派的IP"></a>02 利用命令提示符查询树莓派的IP</h2><p>&ensp;&ensp;Win+R 快捷方式进入命令提示符窗口,然后输入:arp -a,找到192.168.137.1IP地址下的第一个IP,(我的为192.168.137.9)此IP为主机为树莓派分配的一个IP,然后打开Putty,输入刚才的IP地址后点击Open既可以。</p>
<p><img src="https://s1.ax1x.com/2020/03/16/8YZ1m9.png" alt="8YZ1m9.png"></p>
<h2 id="03-Putty连接至树莓派"><a href="#03-Putty连接至树莓派" class="headerlink" title="03 Putty连接至树莓派"></a>03 Putty连接至树莓派</h2><p>&ensp;&ensp;putty中输入树莓派分配到的IP:</p>
<p><img src="https://s1.ax1x.com/2020/03/16/8YQ9Nd.png" alt="8YQ9Nd.png"></p>
<p>&ensp;&ensp;接着就会进入到树莓派的登录界面:用户名默认是:pi,默认的密码是:raspberry.在输入密码时不会显示密码,输入完成后点击Enter键即可,如下图所示:</p>
<p><img src="https://s1.ax1x.com/2020/03/16/8YMkmF.png" alt="8YMkmF.png"></p>
<p>&ensp;&ensp;熟悉Linux的童鞋们到此步就可以在树莓派的Linux系统下尽情徜徉了,但对于我等刚入门者还需要一个UI界面比较容易接收和学习,下面介绍如何利用VNC来实现树莓派系统的UI界面.</p>
<h2 id="04开启VNC功能-实现树莓派的UI界面"><a href="#04开启VNC功能-实现树莓派的UI界面" class="headerlink" title="04开启VNC功能,实现树莓派的UI界面"></a>04开启VNC功能,实现树莓派的UI界面</h2><p>&ensp;&ensp;在上图的命令窗口中输入vncserver,开启VNC功能</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">vncserver</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/03/16/8YMClV.png" alt="8YMClV.png"></p>
<p>&ensp;&ensp;然后打开VNCViewer,再次输入主机为树莓派分配的IP然后弹出如下界面就代表连接成功</p>
<p><img src="https://s1.ax1x.com/2020/03/16/8YKoWt.png" alt="8YKoWt.png"></p>
<p>&ensp;&ensp;点击Continue,默认的登录密码是raspberry,输入密码后点击OK</p>
<p><img src="https://s1.ax1x.com/2020/03/16/8YMtfI.png" alt="8YMtfI.png"></p>
<p>&ensp;&ensp;Congratulations!,现在你可以开启你的树莓派的学习之旅了</p>
<p><img src="https://s1.ax1x.com/2020/03/16/8YMXjK.png" alt="8YMXjK.png"></p>
<h2 id="05写在后面"><a href="#05写在后面" class="headerlink" title="05写在后面"></a>05写在后面</h2><p>&ensp;&ensp;虽然网上可以买到树莓派的显示屏,或者直接找一台显示屏通过HDMI接口即可作为树莓派的显示屏,但上述两种选择对我来说完全没有必要,单独购买显示屏需要另外花钱不说,给其配一台显示器导致其便携性下降.所以,直接利用自己的笔记本来当显示屏是一个非常好的选择.</p>
<p>&ensp;&ensp;作为卡片电脑,树莓派的功能十分强大,学习其GPIO口基本上可以将其当做一块微控制器来玩.另外其具有无线模块,在油管上看到有将树莓派当作软路由的教程,呵呵,搭一个路由器,全宿舍,全家科学上网,岂不美哉!!!</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>树莓派 VNC</tag>
      </tags>
  </entry>
  <entry>
    <title>Git将本地文件上传至Github仓库</title>
    <url>/2020/03/10/009git%E5%B7%A5%E5%85%B7%E4%B8%8A%E4%BC%A0%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E8%87%B3github%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<p>🖨️使用git工具将本地文件上传至项目托管平台，方便自己对项目进行日常的更新管理以及实现项目的共享，下面简要介绍一些步骤：</p>
<a id="more"></a>
<h1 id="📌git工具上传本地文件项目至github远程仓库"><a href="#📌git工具上传本地文件项目至github远程仓库" class="headerlink" title="📌git工具上传本地文件项目至github远程仓库"></a>📌git工具上传本地文件项目至github远程仓库</h1><ol>
<li>📎在Github上新建一个仓库，并命名</li>
<li>📎在本地文件下下右键，选择GitBash Here打开git工具</li>
<li>📎命令行中首先输入：git init  (然后可以利用ls语句来检查一下项目文件下的所有文件)</li>
<li>📎输入：git add .   然后回车</li>
<li>📎输入：git commit -m’对项目的说明’</li>
<li>📎然后输入：git remote add origin <a href="https://github.com/DecaprioTesla/Tempure_measure.git" target="_blank" rel="noopener">https://github.com/DecaprioTesla/Tempure_measure.git</a>  （网址为Github仓库分配的网页）</li>
<li>📎最后输入： git push -u origin master (首次使用可能需要输入用户名和密码)</li>
</ol>
<h1 id="📌本地项目做修改后重新上传至github远程仓库"><a href="#📌本地项目做修改后重新上传至github远程仓库" class="headerlink" title="📌本地项目做修改后重新上传至github远程仓库"></a>📌本地项目做修改后重新上传至github远程仓库</h1><ol>
<li>📎对本地文件做一定的修改，加入新的文件等等</li>
<li>📎记住所作修改或添加的文件，然后：git add 修改的文件名称.格式</li>
<li>📎输入：git commit -m’添加修改说明’</li>
<li>📎输入：git pull –rebase origin master</li>
<li>📎最后输入 git push -u origin master上传修改或添加的文件的文件</li>
</ol>
]]></content>
      <categories>
        <category>技术理论</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>上传仓库</tag>
      </tags>
  </entry>
  <entry>
    <title>胡适日记</title>
    <url>/2020/03/08/008%E8%83%A1%E9%80%82%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<center><font face="黑体" color="black" size="5">颓废日记全篇</font></center>

<p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1583688617647&di=679b46139e9339467bbb1e2d28603249&imgtype=0&src=http%3A%2F%2Fimg1.gtimg.com%2Fninja%2F1%2F2019%2F05%2Fninja155694486387376.png" alt="图"></p>
<a id="more"></a>
<center><font face="黑体" color="black" size="4">打牌日记</font></center>

<blockquote>
<p>七月二日：天热不能作事，打牌消遣；</p>
</blockquote>
<blockquote>
<p>七月三日：今日天气百一十度。打牌。</p>
</blockquote>
<blockquote>
<p>七月五日：往暑期学校注册。打牌。</p>
</blockquote>
<blockquote>
<p>七月六日：暑期学校注册，化学。打牌。</p>
</blockquote>
<blockquote>
<p>七月七日：上课，打牌。</p>
</blockquote>
<blockquote>
<p>七月八日：无课，打牌，天作稍凉矣。</p>
</blockquote>
<blockquote>
<p>七月廿一日：化学第二小测试……打牌。</p>
</blockquote>
<blockquote>
<p>七月廿二日：打牌，读美国短篇名著数种。</p>
</blockquote>
<blockquote>
<p>七月廿四日：上课，得意争一书，打牌，演化学算题</p>
</blockquote>
<blockquote>
<p>七月廿五日：上课，作书复德争。打牌。</p>
</blockquote>
<p><img src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2933670769,1198485342&fm=26&gp=0.jpg" alt="图"></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>划水</tag>
      </tags>
  </entry>
  <entry>
    <title>自适应控制（二）</title>
    <url>/2020/03/07/007%E5%9F%BA%E4%BA%8E%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5%E8%87%AA%E6%A0%A1%E6%AD%A3%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
    <content><![CDATA[<h1 id="基于优化策略自校正控制器"><a href="#基于优化策略自校正控制器" class="headerlink" title="基于优化策略自校正控制器"></a>基于优化策略自校正控制器</h1><p>&emsp;&emsp;几十年来，常规的PID控制器的研究，不论是在理论还是实践上都作了大量的工作，因而被应用于各种过程控制，并得到了良好的效果。随着科学技术的发展人们对控制的系统的要求越来越高，特别是那些被控参数是未知或存在参数变化或不确定扰动的控制过程，想要取得良好的控制效果，就必须进行在线调节控制器得参数。但是想要对PID控制器进行在线参数调节是十分困难的。如果采用自校正技术就可以自动调节调节器或控制参数，使系统在较好的性能下运行。</p>
<a id="more"></a>
<h2 id="1-最小方差控制"><a href="#1-最小方差控制" class="headerlink" title="1.最小方差控制"></a>1.最小方差控制</h2><h3 id="1-1提出"><a href="#1-1提出" class="headerlink" title="1.1提出"></a>1.1提出</h3><p>&emsp;&emsp;最小方差控制的概念（Self-tuning Regulators，自校正调节器）最初由Åström等人在1973年提出。目的是最大限度地减小干扰对系统的影响。</p>
<h3 id="1-2最小方差的思想"><a href="#1-2最小方差的思想" class="headerlink" title="1.2最小方差的思想"></a>1.2最小方差的思想</h3><p>&emsp;&emsp;通过保证包含输出的某一随机变量的方差取最小来设计当前时刻的控制量𝑢(𝑘)。为此，必须使得系统输出中包含当前时刻的控制量。假设被控对象或过程存在𝑑步的纯延时，那么当前时刻的控制作用𝑢(𝑘)要滞后𝑑个采样周期才能在输出中体现出来，这样我们可以选择并通过保证包含输出𝑦(𝑘 + 𝑑)的某一变量的方差最小来设计当前时刻的控制量。设计过程中，借助输出量的预测信息计算出当前时刻的控制量。当过程参数未知或时变时先用递推最小二乘法估计相应的参数，或直接估计控制器参数，然后算出𝑢(𝑘)。这样，通过连续不断地进行预测和控制，就能始终保持输出的某一方差一直取最小。</p>
<ol>
<li>由于输出中必须包含当前时刻的控制量𝑢(𝑘)才能通过使得输出的方差取最小求得当前时刻的控制量，而系统存在𝑑步的纯延时，因此包含当前时刻控制量的最早时刻的系统输出是𝑦(𝑘 + 𝑑) 。这意味着，我们可以选择𝑦(𝑘 + 𝑑) 、并通过使得包含𝑦(𝑘 + 𝑑) 的某一随机变量的方差取最小来计算𝑢(𝑘)。</li>
<li>数学上，用𝑘时刻和之前时刻的控制量和输出量将实际输出𝑦(𝑘 + 𝑑)表示出来的式子称为对𝑘 + 𝑑时刻的实际输出𝑦(𝑘 + 𝑑)的预测模型，因此我们也将实际输出𝑦(𝑘 + 𝑑)称为预测模型的输出。𝑘对每个时刻均成立。</li>
<li>由于未来时刻的实际输出𝑦(𝑘 + 𝑑)是未知的，因此我们只能将其看作一个变量。考虑到当前时刻到𝑘 + 𝑑时刻这段时间内，干扰一直影响着系统，我们进<br>一步将实际输出或预测模型的输出𝑦(𝑘 + 𝑑)看作一个随机变量是合理的。</li>
<li>由于自校正的功能一般都是用小型计算机或微处理器实现，因此受控系统的数学模型都用离散形式。<h3 id="1-3单输入单输出受控系统模型"><a href="#1-3单输入单输出受控系统模型" class="headerlink" title="1.3单输入单输出受控系统模型"></a>1.3单输入单输出受控系统模型</h3>&emsp;&emsp;可以用受控自回归滑动平均模型（CARMA）表示（线性、定常、离散）：<br><img src="https://s2.ax1x.com/2020/03/07/3jlrP1.jpg" alt="图"><br>&emsp;&emsp;其中，𝑦(𝑘)为𝑘时刻的输出；𝑢(𝑘)为𝑘时刻的控制输入；{𝜈(𝑘)}是零均值白噪声序列，𝑑为相应滞后步数。引入单位滞后算子𝑞−1，上式可写为<br><img src="https://s2.ax1x.com/2020/03/07/3j3JnU.jpg" alt="图"><br>&emsp;&emsp;其中，<br><img src="https://s2.ax1x.com/2020/03/07/3j3RNd.jpg" alt="图"><br>&emsp;&emsp;红色部分称为滑动平均项，绿色部分称为自回归项。（2）式也可写为：<br><img src="https://s2.ax1x.com/2020/03/07/3j89DU.jpg" alt="图"><br>&emsp;&emsp;其中，红色部分被称为过程或对象模型；绿色部分被称为噪声模型，也称为成形滤波器。<br><img src="https://i.loli.net/2020/03/07/ulotJHgsEwnN8ij.jpg" alt="5.JPG"><br>&emsp;&emsp;绿色部分能看作是白噪声经线性环节的输出，一般为有色噪声。<br>&emsp;&emsp;一般地，多项式𝑃 𝑧 在𝑧平面上的根或零点指满足𝑃 𝑧 = 0的𝑧的取值。若𝑃 𝑧 的根在𝑧平面上的单位圆内，即𝑧 &lt; 1，则称𝑃 𝑧 为Hurwitz多项式。<h2 id="2-参数已知最小方差控制"><a href="#2-参数已知最小方差控制" class="headerlink" title="2.参数已知最小方差控制"></a>2.参数已知最小方差控制</h2>&emsp;&emsp;假定系统（2）满足以下条件：</li>
</ol>
<blockquote>
<p>受控系统的时延𝑑及延迟算子多项式𝐴、𝐵和𝐶的阶次及系数都是已知的；<br>多项式𝐵和𝐶均为Hurwitz多项式。</p>
</blockquote>
<p>&emsp;&emsp;𝑦(𝑘 + 𝑑)是一个未知的随机变量，我们通过保证包含𝑦(𝑘 + 𝑑)的某一随机变量的方差取最小来设计当前时刻的控制量𝑢(𝑘)。考虑到只能使用当前时刻和过去时刻的输入和输出值，我们需要将𝑦(𝑘 + 𝑑)表达为当前和过去时刻的输入和输出的表达式，然后设计𝑢(𝑘)。由于系统模型（2）中不含实际输出𝑦(𝑘 + 𝑑)，因此需要对模型（2）进行变换以得到包含𝑦(𝑘 + 𝑑)的模型，这样即可用于实现包含𝑦(𝑘 + 𝑑)的某一随机变量的方差的最小化。将基于模型（2）变换得到的、包含𝑦(𝑘 + 𝑑)的模型称为预测模型。</p>
<h3 id="2-1最小方差预测得出现"><a href="#2-1最小方差预测得出现" class="headerlink" title="2.1最小方差预测得出现"></a>2.1最小方差预测得出现</h3><p><strong>几个符号的含义</strong></p>
<p>&emsp;&emsp;𝑦(𝑘+𝑑)：未来时刻𝑘+𝑑的系统实际输出本身，或𝑘+𝑑时刻预测模型的输出，代表一个随机变量。</p>
<p>&emsp;&emsp;𝑦𝑘+𝑑/𝑘：基于𝑘和以前时刻的输入输出数据{𝑢𝑖,𝑦𝑖,𝑖≤𝑘}，对未来时刻𝑘+𝑑时的系统实际输出本身或预测模型输出𝑦(𝑘+𝑑)的预测估计。也记为 𝑦𝑘+𝑑/𝑘。</p>
<p>&emsp;&emsp;𝑦𝑘+𝑑/𝑘=𝑦𝑘+𝑑−𝑦𝑘+𝑑/𝑘：预测误差。也记为 𝑦𝑘+𝑑。</p>
<p><strong>预测模型</strong></p>
<p>&emsp;&emsp;将（3）式写为<br><img src="https://i.loli.net/2020/03/07/eaCUg8oiNpv1JVQ.jpg" alt="6.JPG"><br>&emsp;&emsp;令红色部分为<br><img src="https://i.loli.net/2020/03/07/E3mj9yfYATwCRZz.jpg" alt="7.JPG"><br>&emsp;&emsp;其中<br><img src="https://i.loli.net/2020/03/07/GNU3MnRZq5jcW74.jpg" alt="8.JPG"><br>&emsp;&emsp;基于引入𝑞−𝑑的目的，由（6）式中的红色部分可知，𝐹 𝑞−1 的次数是𝑑 − 1，即𝑛𝑓 = 𝑑 − 1</p>
<p>&emsp;&emsp;将（5）式代入（4）式可得<br><img src="https://i.loli.net/2020/03/07/39nFPQXOfBtvRil.jpg" alt="9.JPG"><br>&emsp;&emsp;由（3）式可得<br><img src="https://i.loli.net/2020/03/07/Fk9UpmAMrB8Ooys.jpg" alt="10.JPG"><br>&emsp;&emsp;将（7）式代入（6）式可得<br><img src="https://i.loli.net/2020/03/07/TnhFeWvacp8zCro.jpg" alt="11.JPG"><br>&emsp;&emsp;观察（8）式，可以推测：红色部分是对于实际输出𝑦𝑘+𝑑的最优预测值。</p>
<p><strong>最优预测器</strong></p>
<p><img src="https://i.loli.net/2020/03/07/rtQeW4mSYxX3u9j.jpg" alt="12.JPG"><br>&emsp;&emsp;由于𝜈(𝑘 + 𝑑)与𝑦(𝑘)、𝑢(𝑘)相互独立，因此也与𝑦 𝑘 + 𝑑/𝑘 相互独立，故上式右边最后一项为0. 第一项是不可预测的，所以欲使𝐽1最小，只有使上式右边第二项为0，此时有：<br><img src="https://i.loli.net/2020/03/07/mop15JCzMRlgHbE.jpg" alt="13.JPG"><br>&emsp;&emsp;最小预测方差为：<br><img src="https://i.loli.net/2020/03/07/PfLx3grQEWSABhT.jpg" alt="14.JPG"><br>&emsp;&emsp;以上的预测模型以及最优预测器均是在假定𝐶 𝑞−1 是Hurwitz多项式的前提下得出的结果，即𝐶 𝑞−1 关于𝑞的根全部落在𝑞平面的单位圆内，这就保证了初始条件对最优预测器的作用与影响是以指数型速度衰减的。所以𝑘足够大时相当于稳态下的预测，也即初始条件的影响就无关紧要了。有时又称为最优稳态预测器。已有人提出当𝐶 𝑞−1 具有单位圆上零点的次最优预测器。</p>
<p>&emsp;&emsp;最优预测器（9）中出现了𝐹 𝑞−1 和𝐺 𝑞−1 ，故使用中必须确定出这两个量。一般地，当多项式𝐴 𝑞−1 、𝐶 𝑞−1 和时延步数𝑑已知后，这两个量可通过求解Diophantine方程唯一确定</p>
<p>&emsp;&emsp;Diophantine方程有两种解法，一种是长除法，另一种是比较系数法。</p>
<h3 id="2-2最小方差控制"><a href="#2-2最小方差控制" class="headerlink" title="2.2最小方差控制"></a>2.2最小方差控制</h3><p>&emsp;&emsp;通过使得实际输出𝑦(𝑘 + 𝑑)与期望输出𝑦𝑟 (𝑘 + 𝑑)之间的误差的方差𝐽 =𝐸 𝑦 𝑘 + 𝑑 − 𝑦𝑟 (𝑘 + 𝑑) 2 取最小，设计当前时刻的控制律𝑢(𝑘)。<br>&emsp;&emsp;将预测模型（8）代入性能指标𝐽，并考虑最优预测方程（9）有：<br><img src="https://i.loli.net/2020/03/07/mN6cyEAbShgKVxv.jpg" alt="15.JPG"><br>&emsp;&emsp;上式右边第一项不可控，所以欲使𝐽最小，必须使<br><img src="https://i.loli.net/2020/03/07/OvQV5YT6qmSe9Mi.jpg" alt="16.JPG"><br>&emsp;&emsp;将最优预测的具体表达式代入上式，并经整理可得<br><img src="https://i.loli.net/2020/03/07/en4SYD6gtfmbFLq.jpg" alt="17.JPG"><br>&emsp;&emsp;从以上推导过程可以看出，最小方差控制律实际上是令𝑘 + 𝑑时刻的最优输出预测值等于期望输出时所得到的控制量。</p>
<p>&emsp;&emsp;特别地，对于输出调节问题，有𝑦𝑟 𝑘 + 𝑑 = 0。此时的最小方差控制律也称为最小方差调节律，可以简化为<br><img src="https://i.loli.net/2020/03/07/eGkDbzXmyTLUOcv.jpg" alt="18.JPG"><br><strong>最小方差控制设计概括</strong></p>
<ol>
<li>设被控过程的差分方程为𝐴 𝑞−1 𝑦 𝑘 = 𝐵 𝑞−1 𝑞−𝑑 𝑢 𝑘 + 𝐶 𝑞−1 𝜈 𝑘 ，其中，{𝜈(𝑘)}是独立同分布的白噪声序列，即𝜈(𝑘)~𝑁(0, 𝜎2)；𝐵和𝐶均为Hurwitz多项式。那么，最小方差调节律为<br><img src="https://i.loli.net/2020/03/07/SCfPH9GZ26sJLkx.jpg" alt="19.JPG"></li>
<li>其中，多项式𝐹 𝑞−1 和𝐺 𝑞−1 的阶分别为𝑑 − 1和𝑛𝑎 − 1；多项式的系数可通过求解下列Diophantine方程来确定：<br><img src="https://i.loli.net/2020/03/07/Roa9pSxhB1PVNrU.jpg" alt="20.JPG"></li>
<li>控制律作用下的输出误差是𝑣(𝑘 + 𝑑)的𝑑 − 1阶滑动平均：<br><img src="https://pic.downk.cc/item/5e63a9e998271cb2b8f41296.jpg" alt="20.JPG"></li>
<li>输出误差的最小方差为<br><img src="https://pic.downk.cc/item/5e63a9e998271cb2b8f4129d.jpg" alt="20.JPG"></li>
</ol>
<p><strong>最小方差控制的特性</strong></p>
<ol>
<li>输出误差的方差随系统延迟𝑑的增加而增加，即特性变坏。</li>
<li>当增益𝑏0的绝对值很小时，调节器的增益很大，将导致过大的控制信号𝑢(𝑘)，这会加速调节器执行机构的磨损和损坏。</li>
<li>当受控对象是非最小相位时，最小方差自校正调节系统是不稳定的。</li>
<li>最小方差自校正调节器具有自校正特性。</li>
</ol>
<h2 id="3-参数未知情况下最下方差自校正控制"><a href="#3-参数未知情况下最下方差自校正控制" class="headerlink" title="3.参数未知情况下最下方差自校正控制"></a>3.参数未知情况下最下方差自校正控制</h2><p>&emsp;&emsp;最小方差控制适用于对象参数已知和恒定的场合。当对象受内外干扰的影响以致于其模型不能再有效描述该对象时，就需要对过程模型进行修改，以适应环境条件的变化。修改模型时，可以利用输入输出数据重新辨识模型的结构和参数，也可以只辨识模型的参数而认为结构不变。这就是说，当对象参数变化时，能随着参数的变化在线估计出系统模型，并基于此模型设计出来的、使得期望性能指标达到最优（如输出误差的方差最小）的控制器称为自校正调节器。</p>
<p>&emsp;&emsp;当被控对象的参数未知或变化时将递推最小二乘参数估计与最小方差控制结合起来，就形成了最小方差自校正器。</p>
<p>&emsp;&emsp;自校正控制的两种形式：间接自校正控制和直接自校正控制。</p>
<h3 id="3-1最小方差自校正调节器"><a href="#3-1最小方差自校正调节器" class="headerlink" title="3.1最小方差自校正调节器"></a>3.1最小方差自校正调节器</h3><p>&emsp;&emsp;此时，有𝑦𝑟 𝑘 + 𝑑 = 0。参照最小方差调节器(15)的形式，我们只需要估计出𝐺 𝑞−1 中包含的𝑛𝑎个参数和𝐵 𝑞−1 𝐹 𝑞−1 中包含的𝑛𝑏 + 𝑑个参数即可用于调节器的设计。将预测模型(8)重写如下：<br><img src="https://pic.downk.cc/item/5e63af4498271cb2b8f6669e.jpg" alt><br>&emsp;&emsp;最小方差控制由(15)式确定，即：<br><img src="https://pic.downk.cc/item/5e63af0898271cb2b8f650ce.jpg" alt></p>
<h3 id="3-2最小方差自校正控制器"><a href="#3-2最小方差自校正控制器" class="headerlink" title="3.2最小方差自校正控制器"></a>3.2最小方差自校正控制器</h3><h3 id="3-3最小方差自校正控制算法的收敛性"><a href="#3-3最小方差自校正控制算法的收敛性" class="headerlink" title="3.3最小方差自校正控制算法的收敛性"></a>3.3最小方差自校正控制算法的收敛性</h3><p>&emsp;&emsp;对于最小方差自校正调节算法的收敛性，Åström等人于1973年给出过结论：</p>
<ol>
<li>设被控对象的参数辨识方程如(21)式所示，闭环系统的调节律如(23)所示，若𝑘⟶∞时，参数估计收敛到真值，即 𝜃⟶𝜃’，并且𝐺𝑞−1和𝐹′𝑞−1无公因子，则调节器(23)最终收敛到系统参数已知时的最小方差调节律。</li>
<li>对于最小方差自校正控制器算法也有类似的结论，这时控制器(28)收敛到参数已知时的最小方差控制规律。</li>
</ol>
<p>&emsp;&emsp;总之，被估计的参数收敛到真值，是调节或控制规律收敛到最小方差规律的前提。</p>
]]></content>
      <categories>
        <category>控制理论</category>
      </categories>
      <tags>
        <tag>最小方差</tag>
      </tags>
  </entry>
  <entry>
    <title>反向传播网络</title>
    <url>/2020/03/05/006%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="反向传播网络"><a href="#反向传播网络" class="headerlink" title="反向传播网络"></a>反向传播网络</h1><p>&emsp;&emsp;反向传播网络（Back-Propagation Network,简称BP网络）是对非线性可微分函数进行权值训练的多层前向网络。在人工神经网络的实现应用过程中，80%-90%的采用BP网络或它的变化形式</p>
<a id="more"></a>
<h2 id="1-反向传播网络的模型与结构"><a href="#1-反向传播网络的模型与结构" class="headerlink" title="1.反向传播网络的模型与结构"></a>1.反向传播网络的模型与结构</h2><p>&emsp;&emsp;BP网络是前向网络的核心内容，体现了神经网络的最精华的一部分。一个具有r个输入和一个隐含层的神经网络模型结构如图所示<br><img src="http://q6q6hf6hf.bkt.clouddn.com/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84.JPG" alt="图"></p>
<center>网络模型结构</center>

<p>&emsp;&emsp;在人们掌握反向传播网络设计之前，感知器和自适应线性元件都只能适应于单层的网络模型训练，二者的差别主要在激活函数上，前者是二值型的，后者是线性的。反向传播网络具有一个或多个隐含层，除了在多层网络结构上与之前介绍的模型有不同外，其主要差别在激活函数上。反向传播网络要求激活函数是处处可微的，所以其就不可以采用二值型阈值函数{0，1}或有符号函数{-1，1}，反向传播网络经常使用的是S型激活函数，此激活函数常用对数或双曲正切等一类S形状的曲线表示，如对数S型激活函数关系为：<br><img src="http://q6q6hf6hf.bkt.clouddn.com/%E5%85%AC%E5%BC%8F1.JPG" alt="图"><br>&emsp;&emsp;双曲正切S型激活函数输入输出函数关系为：<br><img src="http://q6q6hf6hf.bkt.clouddn.com/%E5%85%AC%E5%BC%8F2.JPG" alt="图"><br>&emsp;&emsp;下图是是对数S型激活函数和带有偏差的双曲正切S型激活函数的图形<br><img src="http://q6q6hf6hf.bkt.clouddn.com/%E5%AF%B9%E6%95%B0%E5%9E%8B.JPG" alt="图"></p>
<center>对数型</center>

<p><img src="http://q6q6hf6hf.bkt.clouddn.com/%E5%81%8F%E5%B7%AE%E5%9E%8B.JPG" alt="图"></p>
<center>双曲正切型</center>

<h2 id="2-BP算法（误差反向传播法：Back-Propergation）"><a href="#2-BP算法（误差反向传播法：Back-Propergation）" class="headerlink" title="2.BP算法（误差反向传播法：Back-Propergation）"></a>2.BP算法（误差反向传播法：Back-Propergation）</h2><p><img src="http://q6q6hf6hf.bkt.clouddn.com/BP%E8%92%9C%E8%B4%A9.JPG" alt="图"></p>
<center>具有一个隐含层的简化网络图</center>

<p>&emsp;&emsp;设输入为P，输入神经元有r个，隐含层内有s1个神经元，激活函数为F1，输出层内有s2个神经元，对应的激活函数为F2，输出为A，目标矢量为T 。</p>
<h3 id="2-1信息的正向传递"><a href="#2-1信息的正向传递" class="headerlink" title="2.1信息的正向传递"></a>2.1信息的正向传递</h3><h4 id="1-隐含层中第i个神经元的输出为："><a href="#1-隐含层中第i个神经元的输出为：" class="headerlink" title="(1) 隐含层中第i个神经元的输出为："></a>(1) 隐含层中第i个神经元的输出为：</h4><p><img src="http://q6q6hf6hf.bkt.clouddn.com/%E5%85%AC%E5%BC%8F3.JPG" alt="图"></p>
<h4 id="2-输出层第k个神经元的输出为："><a href="#2-输出层第k个神经元的输出为：" class="headerlink" title="(2) 输出层第k个神经元的输出为："></a>(2) 输出层第k个神经元的输出为：</h4><p><img src="http://q6q6hf6hf.bkt.clouddn.com/%E5%85%AC%E5%BC%8F4.JPG" alt="图"></p>
<h4 id="3-定义误差函数为："><a href="#3-定义误差函数为：" class="headerlink" title="(3) 定义误差函数为："></a>(3) 定义误差函数为：</h4><p><img src="http://q6q6hf6hf.bkt.clouddn.com/%E5%85%AC%E5%BC%8F5.JPG" alt="图"></p>
<h3 id="2-2利用梯度下降法求权值变化及误差的反向传播"><a href="#2-2利用梯度下降法求权值变化及误差的反向传播" class="headerlink" title="2.2利用梯度下降法求权值变化及误差的反向传播"></a>2.2利用梯度下降法求权值变化及误差的反向传播</h3><h4 id="1-输出层的权值变化"><a href="#1-输出层的权值变化" class="headerlink" title="(1) 输出层的权值变化"></a>(1) 输出层的权值变化</h4><p>&emsp;&emsp;对从第i个输入到第k个输出的权值有：<br><img src="http://q6q6hf6hf.bkt.clouddn.com/%E5%85%AC%E5%BC%8F6.JPG" alt="图"><br>&emsp;&emsp;其中：<br><img src="http://q6q6hf6hf.bkt.clouddn.com/%E5%85%AC%E5%BC%8F7.JPG" alt="图"><br>&emsp;&emsp;同理可得：<br><img src="http://q6q6hf6hf.bkt.clouddn.com/%E5%85%AC%E5%BC%8F8.JPG" alt="图"></p>
<h4 id="2-隐含层权值变化"><a href="#2-隐含层权值变化" class="headerlink" title="(2) 隐含层权值变化"></a>(2) 隐含层权值变化</h4><p>&emsp;&emsp;对从第j个输入到第i个输出的权值，有：<br><img src="http://q6q6hf6hf.bkt.clouddn.com/%E5%85%AC%E5%BC%8F9.JPG" alt="图"><br>&emsp;&emsp;其中：<br><img src="http://q6q6hf6hf.bkt.clouddn.com/%E5%85%AC%E5%BC%8F10.JPG" alt="图"><br>&emsp;&emsp;同理可得：<br><img src="http://q6q6hf6hf.bkt.clouddn.com/%E5%85%AC%E5%BC%8F11.JPG" alt="图"></p>
<h3 id="2-3误差反向传播的流程"><a href="#2-3误差反向传播的流程" class="headerlink" title="2.3误差反向传播的流程"></a>2.3误差反向传播的流程</h3><p><img src="http://q6q6hf6hf.bkt.clouddn.com/%E8%AF%AF%E5%B7%AE%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E5%9B%BE%E8%A7%A3.JPG" alt="图"></p>
<center>反向传播网络工作流程</center>

<h2 id="3-BP网络的设计"><a href="#3-BP网络的设计" class="headerlink" title="3.BP网络的设计"></a>3.BP网络的设计</h2><p>&emsp;&emsp;在进行BP网络的设计时，一般应从网络的层数、每层网络中的神经元个数和激活函数、初始值以及学习速率等几个方面考虑。下面讨论一下各自速率选区的原则。</p>
<h3 id="3-1网络的层数"><a href="#3-1网络的层数" class="headerlink" title="3.1网络的层数"></a>3.1网络的层数</h3><p>&emsp;&emsp;理论上已经证明：具有偏差和至少一个S型隐含层加上一个线性输出层的网络，能够逼近任何有理函数。增加层数可以进一步降低误差提高精度，但同时也使网络复杂化，从而增加了网络权值的训练时间。而误差精度的提高也可以通过增加隐含层神经元的数目来获得，其训练效果也比增加层数更容易观察和调整。<br>考虑两个单元输入的联想问题。其输入和输出矢量分别为：</p>
<p>&emsp;&emsp;P= [ 3 2 ], T = [ 0.4 0.8]</p>
<p>&emsp;&emsp;当采用含有一个对数S 型单层网络求解时，可求得解为：</p>
<p>&emsp;&emsp;w= 0.3350</p>
<p>&emsp;&emsp;b= 0.5497</p>
<p>&emsp;&emsp;此时所达到的误差平方和err_goal &lt; 0.001 。若将这个误差转换成输出误差时，其绝对误差约为 0.02</p>
<p>&emsp;&emsp;若采用自适应线性网络来实现此联想，得解为：</p>
<p>&emsp;&emsp;w= 0.08</p>
<p>&emsp;&emsp;b= 0.64</p>
<p>&emsp;&emsp;此网络误差为：e = T Y = 0 。<br><img src="http://q6q6hf6hf.bkt.clouddn.com/%E4%B8%A4%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%BD%91%E7%BB%9C.JPG" alt="图"></p>
<center>两种结构比较</center>

<h3 id="3-2隐含层的神经元数"><a href="#3-2隐含层的神经元数" class="headerlink" title="3.2隐含层的神经元数"></a>3.2隐含层的神经元数</h3><p>&emsp;&emsp;网络训练精度的提高可以通过采用增加隐含层神经元的数目来提高，其在结构实现上要比增加神经元层数要简单的多。具体的数是多少要综合考虑精度和复杂度的要求。<br>&emsp;&emsp;用两层BP网络实现“异或”功能。</p>
<p><img src="http://q6q6hf6hf.bkt.clouddn.com/%E4%B8%8D%E5%90%8C%E5%B1%82%E6%95%B0.JPG" alt="图"></p>
<center>每层不同神经元数结构</center>

<h3 id="3-3初始权值的选取"><a href="#3-3初始权值的选取" class="headerlink" title="3.3初始权值的选取"></a>3.3初始权值的选取</h3><p>&emsp;&emsp;较好的初始值时的训练效果的观察。以前面的实例为例，当改用下列初始值：net = initnw(net,1);在这个初始值函数下，获得的一组初始值为：</p>
<p>&emsp;&emsp;W1 = [7 ; 7 ;7 ; 7 ; 7];B1 = [7.0000; 3.5000; 0; 3.5000; 7.0000];</p>
<p>&emsp;&emsp;W2 = [0.2698 0.2135 0.1831 0.7605 0.9237];B2 = [0.0828];</p>
<p>&emsp;&emsp;重新训练网络后，相对于原先随机初始值时的6801 次的训练，仅用了 410 次，就达到了同样的目标误差。这比标准的反向传播法的训练次数少了 15 倍。</p>
<h3 id="3-4学习速率的影响"><a href="#3-4学习速率的影响" class="headerlink" title="3.4学习速率的影响"></a>3.4学习速率的影响</h3><p>&emsp;&emsp;观察不同学习速率的影响<br><img src="http://q6q6hf6hf.bkt.clouddn.com/%E5%AD%A6%E4%B9%A0%E9%80%9F%E7%8E%87.JPG" alt="图"></p>
<center>研究不同学习速率影响</center>

<h2 id="4-BP网络的应用"><a href="#4-BP网络的应用" class="headerlink" title="4.BP网络的应用"></a>4.BP网络的应用</h2><p>&emsp;&emsp;1.<strong>函数逼近</strong>：用输入矢量和相应的输出矢量训练一个网络逼近一个函数；<br>&emsp;&emsp;2.<strong>模式识别</strong>：用一个特定的输出矢量将它与输入矢量联系起来；<br>&emsp;&emsp;3.<strong>分类</strong>：把输入矢量以所定义的合适方式进行分类；<br>&emsp;&emsp;4.<strong>数据压缩</strong>：减少输出矢量维数以便于传输或存储。</p>
<h2 id="5-BP网络的限制与不足"><a href="#5-BP网络的限制与不足" class="headerlink" title="5.BP网络的限制与不足"></a>5.BP网络的限制与不足</h2><p>&emsp;&emsp;<strong>1.需要较长的训练时间</strong></p>
<p>&emsp;&emsp;<strong>2.某些情况下完全不能训练</strong></p>
<p>&emsp;&emsp;<strong>3.可能陷入局部极小值</strong></p>
]]></content>
      <categories>
        <category>控制理论</category>
      </categories>
      <tags>
        <tag>反向传播网络</tag>
      </tags>
  </entry>
  <entry>
    <title>自适应控制（一）</title>
    <url>/2020/03/02/005%E8%87%AA%E9%80%82%E5%BA%94%E6%8E%A7%E5%88%B6%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="自适应控制"><a href="#自适应控制" class="headerlink" title="自适应控制"></a>自适应控制</h1><p>&emsp;&emsp;实际控制系统中，绝大多数被控对象具有不确定性，即其动力学模型和所处的环境不是完全已知的，表现为事先难以确定被控对象的模型参数，或者模型参数是时变的，或者被控对象本身的特性发生变化，此时就需要引入自适应控制。</p>
<a id="more"></a>
<h2 id="1自适应控制的引入"><a href="#1自适应控制的引入" class="headerlink" title="1自适应控制的引入"></a>1自适应控制的引入</h2><h3 id="1-1传统控制理论的局限性"><a href="#1-1传统控制理论的局限性" class="headerlink" title="1.1传统控制理论的局限性"></a>1.1传统控制理论的局限性</h3><p>&emsp;&emsp;现代控制理论通常研究的对象是多输入多输出的线性系统以及一般的非线性系统，当其状态空间运动方程已知，即可借助最优控制理论设计最优控制器，使得控制系统的某一性能指标达到最优（运行时间最短、能耗最小等）。在研究前需要获得系统动力学的数学模型（参数结构），也就是说系统的模型是已知的。但在实际中，绝大多数被控对象具有不确定性，即其动力学模型和所处的环境不是完全已知的，表现为事先难以确定被控对象的模型参数，或者模型参数是时变的，或者被控对象本身的特性发生变化。</p>
<h3 id="1-2自适应控制的发展历史"><a href="#1-2自适应控制的发展历史" class="headerlink" title="1.2自适应控制的发展历史"></a>1.2自适应控制的发展历史</h3><p>&emsp;&emsp;1958年，美国麻省理工学院(MIT)的Whitaker教授首先提出了飞机自动驾驶仪的模型参考自适应控制方案，称为MIT方案。在该方案中采用局部参数优化理论设计自适应控制律，但保证不了系统的稳定性。</p>
<p>&emsp;&emsp;为解决稳定性问题，1965年前后，Shackcloth和Butchar、Parks等人独立引进Lyapunov方法进行模型参考自适应控制律的设计，可保证系统的稳定性。</p>
<p>&emsp;&emsp;1974年，美国的Monopoli提出了一种广义误差信号法，只要采用对象的输入和输出就可以完成设计，避免了微分运算。Monopoli的工作具有里程碑性的意义，他使得模型参考自适应方法变得实用，去掉了求微分运算、增加了稳定性，更适合工程应用。</p>
<p>&emsp;&emsp;1973年，瑞典学者K.J.Åström和B.Wittenmark首先提出最小方差自校正调节器，很容易实现，可以在生产中应用。</p>
<h3 id="1-3自适应控制的特点"><a href="#1-3自适应控制的特点" class="headerlink" title="1.3自适应控制的特点"></a>1.3自适应控制的特点</h3><ul>
<li>能够检测到对象的（性能或模型参数）变化</li>
<li>能够产生基于这种变化的自适应控制率</li>
<li>具有实现可变控制律的可调控制器<h3 id="1-4自适应控制系统基本结构"><a href="#1-4自适应控制系统基本结构" class="headerlink" title="1.4自适应控制系统基本结构"></a>1.4自适应控制系统基本结构</h3>&emsp;&emsp;在经典控制系统的基础之上加入对象的变化检测环节与自适应机构（下图1），对象的变化检测环节是根据系统或对象的输入、输出、可能检测到的干扰来确定出对象本身的变化，例如性能指标值的变化、对象数学模型中某些参数值的变化等，此外也有信息积累的功能。自适应机构根据检测到的对象变化按预先制定的规则产生自适应调节方案，以调整控制器并逐渐实现期望的控制目标。其中，自适应调节方案分参数调节和结构调节两大类，前者只改变控制器的参数，如PID参数整定；后者则会改变控制律的形式。</li>
</ul>
<p><img src="http://q6o2z8cws.bkt.clouddn.com/%E8%87%AA%E9%80%82%E5%BA%94%E7%BB%93%E6%9E%84.JPG" alt="图"></p>
<h3 id="1-5-自适应控制系统中控制器设计的方法"><a href="#1-5-自适应控制系统中控制器设计的方法" class="headerlink" title="1.5 自适应控制系统中控制器设计的方法"></a>1.5 自适应控制系统中控制器设计的方法</h3><blockquote>
<ul>
<li>基于优化策略的自校正控制器</li>
</ul>
</blockquote>
<p>&lt;divalign=center&gt;<img src="http://q6o2z8cws.bkt.clouddn.com/04.JPG" divalign="center"></p>
<p>基于优化策略的自校正控制器主要有如下三种方法：</p>
<p>&emsp;&emsp;1. 最小方差控制</p>
<img src="http://q6o2z8cws.bkt.clouddn.com/01.JPG">

<p>&emsp;&emsp;2. 广义最小方差控制</p>
<img src="http://q6o2z8cws.bkt.clouddn.com/02.JPG">

<p>&emsp;&emsp;3. LQG(先行二次高斯)控制</p>
<img src="http://q6o2z8cws.bkt.clouddn.com/03.JPG">

<blockquote>
<ul>
<li>基于常规控制策略的自校正器</li>
</ul>
</blockquote>
<p>&emsp;&emsp;1. 极点配置法：</p>
<p>&emsp;&emsp;把期望的闭环系统的行为用期望传递函数的（零）极点的位置表示，设计自校正控制器的目的是，保证控制器作用下闭环系统的（零）极点等于或收敛于期望的（零）极点。</p>
<p>&emsp;&emsp;2. PID控制器</p>
<p>&emsp;&emsp;讨论在常规PID控制器作用下如何消除干扰的特殊问题。</p>
<blockquote>
<ul>
<li>模型参考自适应控制</li>
</ul>
</blockquote>
<p>&emsp;&emsp;通过使参考模型输出与对象输出的偏差按一个确定的动态过程趋于零来设计控制律。</p>
<h3 id="1-6自适应控制控制系统主要研究问题"><a href="#1-6自适应控制控制系统主要研究问题" class="headerlink" title="1.6自适应控制控制系统主要研究问题"></a>1.6自适应控制控制系统主要研究问题</h3><p>&emsp;&emsp;自适应控制针对对象和其所处的环境的变化而言，因此需要分析对象的不确定性，其理论涉及概率论、随机过程和系统控制理论。其根本在于设计一个能适应对象和环境变化的自适应控制律。根据对控制系统的基本要求，与自适应律相关的问题有稳定性、收敛性和鲁棒性。</p>
<blockquote>
<ul>
<li>稳定性</li>
</ul>
</blockquote>
<p>&emsp;&emsp;在模型参考自适应控制中，目的是使𝑒⟶0，即要求误差满足Lyapunov渐近稳定性，故稳定性理论是模型参考自适应控制的理论基础。在设计模型参考自适应控制中，Lyapunov稳定性理论和Popov超稳定性理论还是重要的设计工具。</p>
<blockquote>
<ul>
<li>收敛性</li>
</ul>
</blockquote>
<p>&emsp;&emsp;在自适应控制中，收敛性多指算法的收敛性。自适应机构修正控制器从而形成的控制算法、或自校正的参数辨识算法，一般都会出现递推形式，即根据前一步的结果来计算这一步的控制律和参数值。有效的控制结果要求算法必须在有限步后满足要求。收敛算法意味着，参数值最终会收敛到一个确定值。数学上，收敛指一个无限过程。实际使用时，可以指定一个递进误差界，当两步计算所得的参数值之差小于这个误差界时就认为算法已收敛到极限值，停止计算。</p>
<blockquote>
<ul>
<li>鲁棒性</li>
</ul>
</blockquote>
<p>&emsp;&emsp;鲁棒控制和自适应控制的兼容形成鲁棒自适应控制，即自适应控制律具有鲁棒性。鲁棒自适应控制的动机：对于对象或环境的细小变化就引起自适应控制的动作，很多时候是没有必要的，而且过于频繁的启停会大大缩短设备的寿命，甚至导致系统不稳定。</p>
]]></content>
      <categories>
        <category>控制理论</category>
      </categories>
      <tags>
        <tag>自适应控制</tag>
      </tags>
  </entry>
  <entry>
    <title>上海1943</title>
    <url>/2020/03/01/%E9%9A%8F%E7%AC%941/</url>
    <content><![CDATA[<p>&emsp;&emsp;一场突如其来的疫情，给流动的人类社会按下了暂停键。《人类简史》中就曾提到过人类在过去百年面临的三大问题：饥荒、传染病、战争，现在看来其中两个仍然与我们息息相关：战争随时可能会卷土重来，传染病正在爆发。</p>
<a id="more"></a>
<h1 id="小记"><a href="#小记" class="headerlink" title="小记"></a>小记</h1><h2 id="01-世间万物发展之道"><a href="#01-世间万物发展之道" class="headerlink" title="01 世间万物发展之道"></a>01 世间万物发展之道</h2><p>&emsp;&emsp;水溢则慢，月盈而亏，事物的发展也是如此，人类社会不可能始终处于发展前进的阶段，总会在前进的道路上出现一些差错。这次疫情的爆发可以说是事物发展过程中的必然事件，这不仅与病毒本身有关，诚然也与人类的社会结构与性质相联系。对当下生活的人而言其可谓一场灾难，但就事件发展之道或历史进程而言，其可能就是“2020年，新冠病毒在中国爆发并在全球蔓延”一句话这么简单。</p>
<h2 id="02-人类生存之本"><a href="#02-人类生存之本" class="headerlink" title="02 人类生存之本"></a>02 人类生存之本</h2><p>&emsp;&emsp;直立行走加上制造和使用工具完成了对人类的定义，直立行走改变了大脑结构，制造和使用工具促使人类改造和探索自然，前后两者亦即想法的诞生和行为的执行，也就是理论和时间相结合。不得不说人类的进步不得不依赖于提出那些拥有里程碑意义想法的人：神秘东方的孔子、老子，西方的亚里士多德、柏拉图、康德等，当然还有我们的马克思。也有一些诸如牛顿，达尔文，爱因斯坦之类。思想本身是一种抽象化的东西，但大思想家就能将抽象的思想转化成人们心中潜在的意识，可能这就是神奇的所在之处。同时有些思想抽象成理论并能在现实中体现出来并发挥出功用，使得人类足以生存甚至去挑战自然。</p>
<h2 id="03-全局与整体"><a href="#03-全局与整体" class="headerlink" title="03 全局与整体"></a>03 全局与整体</h2><p>&emsp;&emsp;个体与周围的个体加上生活空间可谓社会，所以个体与个体，个体与生活空间的关系是社会的关键，上述两者之间的交集是思想和行为。</p>
<h2 id="04-结语"><a href="#04-结语" class="headerlink" title="04 结语"></a>04 结语</h2><p>&emsp;&emsp;说人话：就是盼着：疫情尽快结束，万物长新！</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>博客域名更改</title>
    <url>/2020/02/29/004%E6%9B%B4%E6%94%B9%E5%9F%9F%E5%90%8D/</url>
    <content><![CDATA[<p>&emsp;&emsp;利用hexo和Github搭建完博客后默认的域名是以.github.io结尾的，依托于github的服务器，除非利用国外的IP去访问否则在国内博客加载的速度非常慢因此下面介绍如何购买阿里云的域名来重新部署自己的博客</p>
<h1 id="域名更改步骤总结"><a href="#域名更改步骤总结" class="headerlink" title="域名更改步骤总结"></a>域名更改步骤总结</h1><a id="more"></a>
<h2 id="1-购买域名"><a href="#1-购买域名" class="headerlink" title="1 购买域名"></a>1 购买域名</h2><p>&emsp;&emsp;首先注册一个阿里云账号（建议支付宝快捷方式注册）注册完后登录进入阿里云。在域名搜索栏中输入自己想要购买的域名，阿里云会根据域名的流行度推荐不同后缀的域名当然他们的价位也大不相同，根据自己的需要选择购买域名的时间然后加入购物车</p>
<p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1582992536696&di=e93f6201a2f40cd28e19553968fea5cf&imgtype=0&src=http%3A%2F%2Fimg.cndesign.com%2Fupload%2Fnews%2F20190322%2F6368885998231690521778966.png" alt="aliyun"></p>
<p>&emsp;&emsp;在进行支付之前需要完善自己的信息包括邮箱身份证以及上传身份证正面图片，然后提交审核，审核时间大概在五分钟左右（赚钱的行当当然效率高）。接着完成支付，然后就恭喜你你可以有自己的域名了。</p>
<h2 id="2-解析域名并在Github中添加域名信息"><a href="#2-解析域名并在Github中添加域名信息" class="headerlink" title="2 解析域名并在Github中添加域名信息"></a>2 解析域名并在Github中添加域名信息</h2><p>&emsp;&emsp;在新购买的域名右侧点击解析，然后去填写里面的内容：主机记录–@ ；记录类型选择–CNAME；解析线路默认；记录值–username.github.io;(最关键)</p>
<p><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=655537167,4042667359&fm=26&gp=0.jpg" alt="avatar"></p>
<p>&emsp;&emsp;然后回到Github中博客的仓库，进入最右侧的Settings，下拉进入到GithubPages，在custom domain中填入自己购买的域名然后点击save</p>
<p><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2710692682,3036501525&fm=15&gp=0.jpg" alt="avatar"></p>
<p>&emsp;&emsp;这时再次输入username.github.io网址栏中会自动变为购买的域名，但刚开始可能加载不出来任何东西，建议等待一段时间后再次尝试</p>
<h2 id="3-完结"><a href="#3-完结" class="headerlink" title="3 完结"></a>3 完结</h2><p>&emsp;&emsp;等待一段时间后再次尝试，发现已经正常加载，而且速度快了很多，但是现阶段存在一个问题，自己刚刚生效的域名在QQ中分享时会出现骚扰网站警告⚠，Chrome浏览器中也有拦截，目前还在申诉中，但继续使用usemane.github.io去访问博客不会有警告，网址栏会自动转换为自己购买的域名，加载速度也比较快。</p>
<p><img src="/2020/02/29/004%E6%9B%B4%E6%94%B9%E5%9F%9F%E5%90%8D/02.jpg" alt="02"></p>
]]></content>
      <tags>
        <tag>域名 速度</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Hexo搭建自己的博客</title>
    <url>/2020/02/28/003%E7%AC%AC%E4%B8%80%E7%AF%87%E6%AD%A3%E5%BC%8F%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="Hexo博客搭建"><a href="#Hexo博客搭建" class="headerlink" title="Hexo博客搭建"></a>Hexo博客搭建</h1><a id="more"></a>
<p>今天在刷b站的时候无意中看到一位up主在自己的简介介绍了自己的个人博客，瞬时间我就萌生了搭建个人博客的年头，加之天气阴冷无事可做，当前手头上没有特别紧急的事情，于是一顿操作就搭起来了。</p>
<h2 id="1-搭建博客的方法"><a href="#1-搭建博客的方法" class="headerlink" title="1. 搭建博客的方法"></a>1. 搭建博客的方法</h2><p>主要是在跟着B站的一位UP主学着做的，详情可见链接<a href="https://www.bilibili.com/video/av44544186?t=1156" target="_blank" rel="noopener">搭建博客</a>基本上可以说按照着他的步骤一步一步来就可以成功。下面简要回顾一下搭建的基本步骤：</p>
<h3 id="1-1安装git"><a href="#1-1安装git" class="headerlink" title="1.1安装git"></a>1.1安装git</h3><p>之前只知道有github这个网站，实际上还有一个git软件，git可以用来托管自己的文件或代码方面分布式的交流,搭建hexo博客中对自己的博客设计都是通过git来提交的。<br><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1582913056223&di=1dc371b81afdf0748a5064ffa13fe66c&imgtype=0&src=http%3A%2F%2Fblog.lihaocheng.cn%2Fwp-content%2Fuploads%2F2019%2F03%2F19c3ae1c30f4c948e3de8c2c4226cebc.jpg" alt="git"></p>
<h3 id="1-2配置git"><a href="#1-2配置git" class="headerlink" title="1.2配置git"></a>1.2配置git</h3><h3 id="1-3安装Node-js软件"><a href="#1-3安装Node-js软件" class="headerlink" title="1.3安装Node.js软件"></a>1.3安装Node.js软件</h3><h3 id="1-4将网站部署到Github"><a href="#1-4将网站部署到Github" class="headerlink" title="1.4将网站部署到Github"></a>1.4将网站部署到Github</h3><p>这个步骤要注意自己的博客的网址名称必须要和自己的github账户username保持一致，即username.guithub.io</p>
<h3 id="1-5更换Blog主题"><a href="#1-5更换Blog主题" class="headerlink" title="1.5更换Blog主题"></a>1.5更换Blog主题</h3><p>默认的Blog不够简洁美观，可以按照推荐的yilia主题进行更换</p>
<h3 id="1-6丰富博客的功能和外观"><a href="#1-6丰富博客的功能和外观" class="headerlink" title="1.6丰富博客的功能和外观"></a>1.6丰富博客的功能和外观</h3><p>虽然yilia主题相较于默认的主题有很大改进，但其内部的细节仍有一些需要改进与细化的地方<br>。可以搜索一些大佬们总结的经验和模仿他们的设计风格。其实修改的过程也比较简单，进本是一些代码和参数的<br>ctrl C和ctrl V。</p>
<h2 id="PS"><a href="#PS" class="headerlink" title="PS:"></a>PS:</h2><p>在功能预览网站local那个域名下博客加载速度很快，但真实域名的博客加载速度比较慢，毕竟人家是免费的，尤其是改动较大后首次进入。</p>
<h2 id="2-Markdown格式书写练习"><a href="#2-Markdown格式书写练习" class="headerlink" title="2. Markdown格式书写练习"></a>2. Markdown格式书写练习</h2><p>其实写博客的方式和CSDN基本上是相同的格式，渐渐的熟悉这种格式写起博客来<br>十分方便，戍边也能提升一下盲打的速度</p>
<h2 id="3-搭建完博客后今后的打算"><a href="#3-搭建完博客后今后的打算" class="headerlink" title="3. 搭建完博客后今后的打算"></a>3. 搭建完博客后今后的打算</h2><p>其实很多平台（CSDN，知乎，微博等）也提供了类似博客平台而且功能特别丰富，但是自己动手搭建的感觉是不同的。一个是知道博客的各个功能模块具体是怎样实现的，另外一个是可以直接利用自己的址去分享自己的博客（虽然大平台也可以分享自己的主页地址，但是感觉还是不一样，而且后期可以买个域名）</p>
<p>以后有了这个博客，平时可以写一些技术分享然后传上去，也可写一下个人的感悟和思考，自我的探索以及写一些小文章等等。加入生活没有诗意，那可还行！<br><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1582913205025&di=d28b5f55d7bf3ee903d23edf6c60afeb&imgtype=0&src=http%3A%2F%2F03.imgmini.eastday.com%2Fmobile%2F20180207%2F20180207070834_6d868feb7894e5a33a8f487af4f31e60_1.jpeg" alt="musk"></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown格式测试</title>
    <url>/2020/02/28/002%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%9B%98%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="博文格式测试"><a href="#博文格式测试" class="headerlink" title="博文格式测试"></a>博文格式测试</h1><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><p>内容显示到此行</p>
<a id="more"></a>
<p><font face="黑体" color="green" size="5">我是黑体，绿色，尺寸为5</font><br><font size="4">我是四号字体</font></p>
<h1 id="居中显示举实例"><a href="#居中显示举实例" class="headerlink" title="居中显示举实例"></a>居中显示举实例</h1><center>

<h1 id="斜体显示"><a href="#斜体显示" class="headerlink" title="斜体显示"></a>斜体显示</h1><p><font size="6"><em>斜斜斜斜斜斜</em></font></p>
<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>这是我的第一篇文章</p>
</center>

<h1 id="段落之间间隔显示"><a href="#段落之间间隔显示" class="headerlink" title="段落之间间隔显示"></a>段落之间间隔显示</h1><p>中间间隔一行空行就是段落之间的间隔</p>
<p>这是第一段的内容</p>
<h1 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h1><blockquote>
<p>这是将会被高亮显示的内容</p>
</blockquote>
<h1 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h1><p>[百度]（<a href="https://www.baidu.com/index.php?tn=monline_3_dg）" target="_blank" rel="noopener">https://www.baidu.com/index.php?tn=monline_3_dg）</a></p>
<h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><center>

<p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1582896568401&di=732f42da7677c2fd4b61e10e1c7e1c97&imgtype=0&src=http%3A%2F%2Fimg.ewebweb.com%2Fuploads%2F20190403%2F15%2F1554275984-CghfBeMolO.jpg" alt="风景"></p>
</center>

<h1 id="插入视频"><a href="#插入视频" class="headerlink" title="插入视频"></a>插入视频</h1><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"autoplay":true,"hotkey":true,"preload":"metadata","video":{"url":"https://bestzuo.cn/dreamitpossible.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script> 

<h1 id="空格展示"><a href="#空格展示" class="headerlink" title="空格展示"></a>空格展示</h1><p>&ensp;&ensp;&ensp;&ensp;&ensp;空格展示</p>
<h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">smallerNumbersThanCurrent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">102</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums)</span><br><span class="line">            ++cnt[num + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; cnt.size(); ++i)</span><br><span class="line">            cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)</span><br><span class="line">            nums[i] = cnt[nums[i]];</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>+++++++++++++</p>
<h1 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h1><ul>
<li>无序列表</li>
</ul>
<ul>
<li><p>无序列表</p>
<h1 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h1></li>
</ul>
<ol>
<li>有序列表</li>
<li>有序列表</li>
<li>有序列表<h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1></li>
</ol>
<hr>
<hr>
<hr>
<p> 红色的分割线：<br> <hr style="background-color : red;"></p>
 <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=517554564&auto=1&height=66"></iframe>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
</search>
